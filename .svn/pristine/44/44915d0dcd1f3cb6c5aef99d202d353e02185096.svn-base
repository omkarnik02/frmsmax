from datetime import datetime

from flask import Blueprint, render_template, request, redirect, url_for, session
from app.RuleManagement import RuleManager
import pandas as pd
from app.alert_route import inAlert,upAlert

global role_manager
rule_manager = RuleManager(None, pd.read_csv('app/rules.csv'), pd.read_csv('app/delRules.csv'))

rules_watchlist_routes = Blueprint('rules_watchlist_routes', __name__)
def extract_search_parameters(filtered_rules_data):
    search_id = request.args.get('search_id')
    search_channel = request.args.get('search_channel')
    search_columns = request.args.get('search_columns')
    search_allow_prevent = request.args.get('search_Allow/Prevent')
    search_created_on = request.args.get('search_created_on')
    search_created_by = request.args.get('search_created_by')
    search_status = request.args.get('search_Status')
    search_modified_on = request.args.get('search_modified_on')
    search_modified_by = request.args.get('search_modified_by')

    if search_id:
        filtered_rules_data = filtered_rules_data[filtered_rules_data['id'].astype(str).str.contains(search_id)]
    if search_channel:
        filtered_rules_data = filtered_rules_data[
            filtered_rules_data['channel'].str.contains(search_channel, case=False)]
    if search_columns:
        filtered_rules_data = filtered_rules_data[
            filtered_rules_data['column'].str.contains(search_columns, case=False)]
    if search_allow_prevent:
        filtered_rules_data = filtered_rules_data[
            filtered_rules_data['allowprevent'].str.contains(search_allow_prevent, case=False)]
    if search_created_on:
        try:
            search_created_on_date = datetime.strptime(search_created_on, '%Y-%m-%d').date()
            filtered_rules_data = filtered_rules_data[
                pd.to_datetime(filtered_rules_data['created_on'], errors='coerce').dt.date == search_created_on_date]
        except ValueError:
            pass
    if search_created_by:
        filtered_rules_data = filtered_rules_data[
            filtered_rules_data['created_by'].str.contains(search_created_by, case=False)]
    if search_status:
        filtered_rules_data = filtered_rules_data[filtered_rules_data['status'].str.contains(search_status, case=False)]
    if search_modified_on:
        try:
            search_modified_on_date = datetime.strptime(search_modified_on, '%Y-%m-%d').date()
            filtered_rules_data = filtered_rules_data[
                pd.to_datetime(filtered_rules_data['modified_on'], errors='coerce').dt.date == search_modified_on_date]
        except ValueError:
            pass
    if search_modified_by:
        filtered_rules_data = filtered_rules_data[
            filtered_rules_data['modified_by'].str.contains(search_modified_by, case=False)]

    return filtered_rules_data

    # Debugging output to verify filtered data


@rules_watchlist_routes.route('/rules_watchlist/rules', defaults={'subpath': ''}, methods=['GET', 'POST'])
@rules_watchlist_routes.route('/rules_watchlist/rules/<path:subpath>', methods=['GET', 'POST'])
def rules(subpath):

    userdetails=session.get('userdetails')
    username = session.get('username')
    if not username:
        return redirect(url_for('LoginPage'))  # Redirect to login if session is not set
    rules_data = rule_manager.df
    rules_data = extract_search_parameters(rules_data)
    if request.method == 'POST' and subpath == '':
        # Handle form submission to create rule
        column = request.form['column']
        operator = request.form['operator']
        value = request.form['value']
        allpre = request.form['allpre']
        channel = request.form['channel']

        # Handle rule creation and validation
        message = rule_manager.create_rule(channel, column, operator, value, allpre, username)
        if type(message) is not int:

            return render_template('rules.html', rules=rule_manager.df.to_dict('records'), user=username,
                                   userdetails=userdetails,message=message)


        inAlert({'AlertCategory': 'rule_Addition', 'NavLink': '/rules_watchlist/rules/pending',
                 'Description':username+ '(Maker) added the rule', 'is_seen': 0,
                 'to_whom': 3,
                 'ObjId': message},'group')
    if subpath == 'pending':
        objid = None
        if request.method == 'POST':
            objid = int(request.form['objid'])
            upAlert(int(request.form['altid']))
        pending_rules_data=rules_data[rules_data['appAction']=='Pending'].to_dict('records')
        return render_template('rules.html', rules=pending_rules_data,userdetails=userdetails, user=username ,action=subpath,objid=objid)
    elif subpath == 'declined' :
        objid = None
        if request.method == 'POST':
            objid = int(request.form['objid'])
            upAlert(int(request.form['altid']))
        Approved_rules_data = rules_data[rules_data['appAction'] == 'Declined'].to_dict('records')

        return render_template('rules.html', rules=Approved_rules_data,userdetails=userdetails, user=username,action=subpath,objid=objid)
    elif subpath == 'approved' :
        objid = None
        if request.method == 'POST':
            objid = int(request.form['objid'])
            upAlert(int(request.form['altid']))
        Approved_rules_data = rules_data[rules_data['appAction'] == 'Approved'].to_dict('records')
        return render_template('rules.html', rules=Approved_rules_data,userdetails=userdetails, user=username,action=subpath,objid=objid)
    elif subpath == '' :
        # Handle the default rules page
        Approved_rules_data = rules_data[rules_data['appAction'] == 'Approved'].to_dict('records')
        return render_template('rules.html', rules=Approved_rules_data,userdetails=userdetails, user=username,action=subpath)



@rules_watchlist_routes.route('/rules_watchlist/update/<int:rule_id>', methods=['POST'])
def update_rule(rule_id):
    # Handle updating rule
    username = session.get('username')
    if not username:
        return redirect(url_for('LoginPage'))
    if 'action' in request.form and request.form['action'] == 'approved':
        rule_manager.update_rule(rule_id=rule_id,appstatus= 'Approved',modified_by=username,ActionTookby=username)
        inAlert({'AlertCategory': 'rule_Approved', 'NavLink': '/rules_watchlist/rules/approved',
                 'Description': username+' (Approver) approved the rule', 'is_seen': 0,
                 'to_whom': rule_manager.df[rule_manager.df['id'] == rule_id]['created_by'].values[0],
                 'ObjId': rule_id}, 'personal')
        return redirect(url_for('rules_watchlist_routes.rules',  subpath='pending',user=username))
    elif 'action' in request.form and request.form['action'] == 'alert':
        errmsg= inAlert({'AlertCategory': 'rule_alert', 'NavLink': '/rules_watchlist/rules/pending',
                 'Description': username+' (Maker) re-alert the rule', 'is_seen': 0,
                 'to_whom':3,
                 'ObjId': rule_id}, 'group')

        if errmsg:
            return redirect(url_for('rules_watchlist_routes.rules', subpath='pending', user=username,erromsg=errmsg))
        return redirect(url_for('rules_watchlist_routes.rules', subpath='pending', user=username))
    elif 'action' in request.form and request.form['action'] == 'RequestAgain':
        rule_manager.update_rule(rule_id=rule_id,appstatus= 'Pending',ActionTookby='',modified_by=username)
        inAlert({'AlertCategory': 'rule_Resent', 'NavLink': '/rules_watchlist/rules/pending',
                 'Description': username+' (Maker) resend the rule', 'is_seen': 0,
                 'to_whom':3,
                 'ObjId': rule_id}, 'group')
        return redirect(url_for('rules_watchlist_routes.rules',  subpath='declined',user=username))
    elif 'action' in request.form and request.form['action'] == 'declined':
        rule_manager.update_rule(rule_id=rule_id, appstatus='Declined' ,modified_by=username,ActionTookby=username)
        inAlert({'AlertCategory': 'rule_declined', 'NavLink': '/rules_watchlist/rules/declined',
                 'Description': username +'(Approver) declined the rule', 'is_seen': 0,
                 'to_whom': rule_manager.df[rule_manager.df['id'] == rule_id]['created_by'].values[0],
                 'ObjId': rule_id},'personal')
        return redirect(url_for('rules_watchlist_routes.rules', subpath='pending', user=username))
    elif 'action' in request.form and request.form['action'] == 'reupdate':
        channel = request.form['channel']
        column = request.form['column']
        operator = request.form['operator']
        value = request.form['value']
        rule_manager.update_rule(rule_id, channel, column, operator, value, username)
        return redirect(url_for('rules_watchlist_routes.rules', subpath='declined', user=username))
    else:
        channel = request.form['channel']
        column = request.form['column']
        operator = request.form['operator']
        value = request.form['value']



        rule_manager.update_rule(rule_id, channel, column, operator, value, username)
        return redirect(url_for('rules_watchlist_routes.rules', user=username))


@rules_watchlist_routes.route('/rules_watchlist/delete/<int:rule_id>', methods=['POST'])
def delete_rule(rule_id):
    # Handle deleting rule
    username = session.get('username')
    if not username:
        return redirect(url_for('LoginPage'))  # Redirect to login if session is not set
    rule_manager.delete_rule(rule_id, username)
    if 'action' in request.form and request.form['action'] == 'declined':
        return redirect(url_for('rules_watchlist_routes.rules',  subpath='declined',user=username))
    if 'action' in request.form and request.form['action'] == 'pending':
        return redirect(url_for('rules_watchlist_routes.rules',  subpath='pending',user=username))
    return redirect(url_for('rules_watchlist_routes.rules', user=username))


@rules_watchlist_routes.route('/rules_watchlist/toggle/<int:rule_id>', methods=['POST'])
def toggle_rule(rule_id):
    # Handle toggling rule status
    rule_manager.toggle_rule_status(rule_id)
    return redirect(url_for('rules_watchlist_routes.rules'))

# You can define other routes related to rules and watchlist similarly
